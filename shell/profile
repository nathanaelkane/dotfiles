# inspired by https://github.com/jasoncodes/dotfiles/tree/master/shell

# locale
export LANG=en_AU.UTF-8
export LC_CTYPE=en_US.UTF-8

# editor
export EDITOR='vim'

# general shell settings
export PS1='\u@\h:\w\$ ' # basic prompt - get's overwritten later
export FIGNORE="CVS:.DS_Store:.svn:__Alfresco.url"
alias less='less -iM'
export PAGER='less -SFXiMR'
export MAKEFLAGS='-j 3'
complete -d cd mkdir rmdir

# our own bin dir as the highest priority, followed by /usr/local/bin
export PATH=~/bin:/usr/local/bin:/usr/local/sbin:"$PATH"

# I love colour
if ls --version 2> /dev/null | grep -q 'GNU coreutils'
then
  export GREP_OPTIONS='--color=auto'
  alias ls="ls --color=auto --classify --block-size=\'1"
fi

# history
export HISTSIZE=100000
export HISTFILESIZE=100000
export HISTCONTROL=ignoredups
export HISTTIMEFORMAT="%Y-%m-%d %H:%M:%S  "
export PROMPT_COMMAND='history -a'
shopt -s histappend
PROMPT_COMMAND='history -a; echo "$$ $USER $(history 1)" >> ~/.bash_eternal_history'

# notify of bg job completion immediately
set -o notify

# no mail notifications
shopt -u mailwarn
unset MAILCHECK

# check for window resizing whenever the prompt is displayed
shopt -s checkwinsize
# display "user@hostname: dir" in the window title
if [[ "$TERM" =~ ^xterm ]]
then
  export PROMPT_COMMAND="$PROMPT_COMMAND; "'echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD}\007"'
fi

# load Homebrew's shell completion
if which brew > /dev/null && [ -f "$(brew --prefix)/Library/Contributions/brew_bash_completion.sh" ]
then
  source "$(brew --prefix)/Library/Contributions/brew_bash_completion.sh"
fi

# http://github.com/therubymug/hitch
hitch() {
  command hitch "$@"
  if [[ -s "$HOME/.hitch_export_authors" ]] ; then source "$HOME/.hitch_export_authors" ; fi
}
alias unhitch='hitch -u'

# begin prompt
export PS1=""

# add user@host:path
export PS1="$PS1\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w"

function realpath()
{
  python -c 'import os,sys;print os.path.realpath(sys.argv[1])' "$@"
}

function first_file_match()
{
  local OP="$1"
  shift
  while [ $# -gt 0 ]
  do
    if [ $OP "$1" ]
    then
      echo "$1"
      return 0
    fi
    shift
  done
  return 1
}

# add git status if available
if which git > /dev/null
then
  GIT_COMPLETION_PATH="$(dirname $(realpath "$(which git)"))/../etc/bash_completion.d/git-completion.bash"
fi
if [ ! -f "$GIT_COMPLETION_PATH" ]
then
  GIT_COMPLETION_PATH=$(first_file_match -f \
    "/usr/local/git/contrib/completion/git-completion.bash" \
    "/opt/local/share/doc/git-core/contrib/completion/git-completion.bash" \
    "/etc/bash_completion.d/git" \
  )
fi
if [ -f "$GIT_COMPLETION_PATH" ]
then
  source "$GIT_COMPLETION_PATH"
  GIT_PROMPT_PATH="$(dirname "$GIT_COMPLETION_PATH")/git-prompt.sh"
  if [ -f "$GIT_PROMPT_PATH" ]; then
    source "$GIT_PROMPT_PATH"
    export GIT_PS1_SHOWDIRTYSTATE=1
    export GIT_PS1_SHOWSTASHSTATE=1
    export GIT_PS1_SHOWUNTRACKEDFILES=1
    export PS1="$PS1"'\[\033[01;30m\]$(__git_ps1 " (%s)")'
  fi

  _git_complete() {
    local CMD="$1"
    shift
    for ALIAS in "$@"; do
      __git_complete "$ALIAS" "_git_$CMD"
    done
  }

  _git_complete log gl glp gls glw
  _git_complete checkout gco gcp
  _git_complete status gs
  _git_complete diff gd gdw gds gdsw
  _git_complete reset gar garp
  _git_complete gap _git_add
  _git_complete commit gc gca
  _git_complete push gp
fi

# finish off the prompt
export PS1="$PS1"'\[\033[00m\]\$ '

# initialise rbenv
if [[ -x "`which rbenv`" ]]; then
  eval "$(rbenv init - --no-rehash)"
fi

# initialize Heroku Toolbelt
if [[ -d "/usr/local/heroku/bin" ]]; then
  export PATH="/usr/local/heroku/bin:$PATH"
fi

# initialise autojump
[[ -s `brew --prefix`/etc/autojump.sh ]] && . `brew --prefix`/etc/autojump.sh
